**Для завдання 1:**

**Вхідні дані:**
Розміри матриці: 5 рядків і 4 стовпці.
Мінімальне значення елементів матриці: 1.
Максимальне значення елементів матриці: 10.

**Час виконання програми** Work Stealing = 2 мс, Work Dealing = 5 мс
**Пояснення: **
Work Stealing використовує ForkJoinPool, який динамічно розподіляє задачі між доступними потоками, дозволяючи більш ефективно розподіляти навантаження, особливо на великих обсягах даних. Якщо один потік завершує свою роботу раніше, він може "вкрасти" роботу у іншого потоку, що дозволяє зменшити загальний час виконання.
Work Dealing, з іншого боку, використовує ExecutorService з фіксованим пулом потоків. Тут завдання розподіляються заздалегідь між потоками, і відсутня динамічність у перерозподілі задач. Це може призвести до того, що деякі потоки можуть залишатися з порожніми задачами, якщо обсяг роботи нерівномірно розподілений, що може збільшити загальний час виконання.

**Висновки:**
Work Stealing працює ефективніше у даному випадку, оскільки навантаження автоматично розподіляється між потоками з урахуванням їхнього поточного стану.
Work Dealing має більший час виконання, оскільки тут потоки отримують завдання фіксовано, без можливості "вкрасти" роботу у інших потоків, що може призвести до неефективності.


**Для завдання 2: **

Було обрано підхід Work Stealing, він є більш гнучким, оскільки потоки, які завершили свою роботу раніше, можуть взяти на себе частину роботи інших потоків. Це допомагає оптимізувати використання ресурсів і може прискорити обробку при нерівномірному розподілі задач. У випадку великої кількості файлів або задач, які займають різний час для обробки, цей підхід може бути значно ефективнішим, оскільки дозволяє збалансувати навантаження між потоками, зменшуючи час очікування.Work Stealing виявився швидшим у тестах на малих наборах даних, де кількість файлів не була великою. Проте для більш великих директорій цей підхід буде працювати ефективніше, оскільки потоки можуть динамічно коригувати своє навантаження.
